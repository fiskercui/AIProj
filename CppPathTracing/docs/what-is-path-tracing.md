# 什么是路径追踪（Path Tracing）？

## 🎬 从现实世界说起

想象一下你在看这个文档的时候：

1. **太阳/灯光**发出光线
2. 光线在房间里**到处反弹**（墙壁、桌子、你的屏幕）
3. 最终一些光线进入你的**眼睛**
4. 你的大脑处理这些光线，形成**图像**

这就是我们**看到东西**的过程！路径追踪就是用计算机**模拟这个真实的物理过程**。

---

## 🖼️ 传统渲染 vs 路径追踪

### 传统光栅化渲染（游戏常用）

```
相机 → 直接计算物体颜色 → 屏幕
      ↓
   假装有光照（快但不真实）
```

**特点：**
- ✅ 非常快（每秒60-144帧）
- ❌ 反射/折射需要复杂技巧
- ❌ 软阴影、全局光照很难实现
- ❌ 看起来"假"

### 路径追踪（电影级渲染）

```
相机 → 发射光线 → 物体 → 反弹 → 光源
  ↑                  ↓
  └──────── 递归追踪 ←─────┘
```

**特点：**
- ✅ 物理正确（真实的光照）
- ✅ 自动处理反射、折射、软阴影
- ✅ 看起来像照片
- ❌ 很慢（需要大量计算）

---

## 🔍 路径追踪的工作原理

### 核心思想：逆向追踪光线

现实中：**光源 → 物体 → 眼睛**

但这样效率太低！大部分光线根本不会进入眼睛。

路径追踪：**眼睛（相机）→ 物体 → 光源**

这样只计算能看到的光线！

---

## 📊 详细步骤演示

### 步骤 1: 从相机发射光线

```
屏幕
┌───────────┐
│ ● ● ● ● ● │  每个像素发射一条光线
│ ● ● ● ● ● │     ↓ ↓ ↓ ↓ ↓
│ ● ● ● ● ● │      相机
└───────────┘
```

### 步骤 2: 检测光线碰撞

```
    光线
     ↓
  ───────→ ●  ← 击中球体！
          ╱ ╲
         │   │
          ╲_╱
```

### 步骤 3: 根据材质处理光线

#### 漫反射材质（哑光）

```
入射光线 ↓
         ●
        ╱│╲
       ╱ │ ╲   → 光线散射到随机方向
      ╱  │  ╲
     ↙   ↓   ↘
```

#### 金属材质（镜面）

```
入射光线 ↓
         ●
         │╲
         │ ╲   → 光线像镜子一样反射
         │  ↘
        法线  反射光线
```

#### 玻璃材质（透明）

```
入射光线 ↓
         ●
        ╱│╲
       ╱ │ ╲   → 部分反射 + 部分折射
      ↙  ↓  ↘
   反射  折射  进入玻璃内部
```

### 步骤 4: 递归追踪（重点！）

这是路径追踪的**核心**！

```
第1次反弹：相机 → 蓝色球体
            ↓
第2次反弹：球体 → 墙壁
            ↓
第3次反弹：墙壁 → 天空（光源）
            ↓
         收集到光！
```

每次反弹，光线的**能量会衰减**（乘以材质的颜色）。

---

## 💻 代码中的体现

让我们看看 [`main.cpp`](src/main.cpp:14) 中的核心函数：

```cpp
Color ray_color(const Ray& r, const Hittable& world, int depth) {
    // 递归终止条件：达到最大深度
    if (depth <= 0)
        return Color(0, 0, 0);  // 黑色（没有光）
    
    HitRecord rec;
    
    // 检查光线是否击中物体
    if (world.hit(r, 0.001, infinity, rec)) {
        Ray scattered;
        Color attenuation;
        
        // 询问材质：光线如何散射？
        if (rec.material->scatter(r, rec, attenuation, scattered)) {
            // 递归！追踪散射的光线
            return attenuation * ray_color(scattered, world, depth - 1);
            //     ↑ 颜色衰减    ↑ 递归调用（下一次反弹）
        }
        
        return Color(0, 0, 0);  // 材质吸收了所有光
    }
    
    // 没击中任何物体 → 击中天空（背景光）
    return sky_color(r);
}
```

---

## 🎨 为什么需要多次采样？

### 问题：噪点

单条光线只能采样**一个随机方向**，结果会很"吵"：

```
单次采样：
█▓░▓█░▓█  ← 充满噪点，看起来像沙子
░█▓░█▓░▓
▓░█▓░█▓░
```

### 解决方案：多次采样求平均

对每个像素发射**100条光线**，然后求平均：

```
100次采样：
████████  ← 平滑、干净
████████
████████
```

这就是我们在 [`main.cpp`](src/main.cpp:134) 中做的：

```cpp
const int samples_per_pixel = 100;  // 每像素100次采样

for (int s = 0; s < samples_per_pixel; ++s) {
    // 每次采样略微偏移光线方向
    Ray r = get_ray_with_random_offset(...);
    pixel_color += ray_color(r, world, max_depth);
}

pixel_color /= samples_per_pixel;  // 求平均
```

---

## 🌟 路径追踪的优势

### 1. 物理正确的光照

**传统渲染**需要程序员手写每种效果：
- 反射？写反射代码
- 折射？写折射代码
- 软阴影？写软阴影代码
- 间接光照？非常复杂...

**路径追踪**：自动得到所有效果！
- ✅ 镜面反射
- ✅ 玻璃折射
- ✅ 软阴影
- ✅ 颜色渗透（Color Bleeding）
- ✅ 焦散（Caustics）
- ✅ 全局光照（Global Illumination）

### 2. 真实的材质表现

看你的渲染结果：
- 🔵 蓝色球体：柔和的漫反射
- ⚪ 金属球：清晰的反射
- 💎 玻璃球：同时有反射和折射

这些都是**自动**产生的，不需要特殊处理！

### 3. 容易扩展

想添加新材质？只需实现 `scatter()` 函数：

```cpp
class MyCustomMaterial : public Material {
    virtual bool scatter(...) {
        // 定义这个材质如何散射光线
        return true;
    }
};
```

---

## 🎭 路径追踪的挑战

### 1. 性能问题

**为什么慢？**

假设：
- 图像：400×225 = 90,000 像素
- 每像素：100 次采样
- 每条光线：最多 50 次反弹

总计算量：90,000 × 100 × 50 = **4.5 亿次**光线测试！

这就是为什么：
- 游戏用光栅化（实时）
- 电影用路径追踪（离线渲染）

### 2. 噪点问题

采样越少 → 噪点越多
采样越多 → 越慢

需要在**质量**和**速度**之间平衡。

### 3. 解决方案

**硬件加速：**
- RTX 显卡专门加速光线追踪
- 现代游戏开始使用混合渲染（部分路径追踪）

**算法优化：**
- 重要性采样（Importance Sampling）
- 降噪算法（Denoising）
- BVH 加速结构

---

## 🎓 蒙特卡洛方法

路径追踪使用**蒙特卡洛方法**：

### 什么是蒙特卡洛？

通过**大量随机采样**来估算结果。

**类比：估算圆周率**

```
正方形内随机撒点
┌─────────┐
│  ●●●●●  │   落在圆内的点 / 总点数 ≈ π/4
│ ●●●●●●● │
│●●●●●●●●│   点越多，结果越准确
│ ●●●●●●● │
│  ●●●●●  │
└─────────┘
```

**路径追踪也是一样：**
- 每条光线 = 一个样本
- 样本越多 = 图像越准确
- 100 次采样 = 100 个样本求平均

---

## 🌈 光照的物理本质

### 渲染方程（The Rendering Equation）

这是计算机图形学的核心方程：

```
L(出射光) = L(自发光) + ∫ f(材质) × L(入射光) × cos(θ) dω
                         ↑
                    所有方向的积分
```

**简化理解：**

```
一个点的亮度 = 它自己发光 + 从其他地方反射来的光
```

路径追踪就是用**蒙特卡洛方法**求解这个积分！

---

## 🎯 实际应用

### 1. 电影特效（最常见）

- 皮克斯、迪士尼动画
- 漫威电影特效
- 《阿凡达》等大片

### 2. 建筑可视化

- 建筑设计预览
- 室内设计
- 照明效果模拟

### 3. 产品设计

- 汽车渲染
- 产品广告
- 珠宝展示

### 4. 现代游戏

- Minecraft RTX（实时路径追踪）
- Cyberpunk 2077（混合渲染）
- Quake II RTX

---

## 🚀 你的渲染器能做什么？

### 已实现的功能

1. **基础路径追踪**
   - ✅ 递归光线追踪
   - ✅ 随机采样
   - ✅ 多次反弹

2. **真实材质**
   - ✅ 漫反射（Lambertian）
   - ✅ 金属反射（Metal）
   - ✅ 玻璃折射（Dielectric）

3. **图像质量**
   - ✅ 100次抗锯齿
   - ✅ Gamma校正
   - ✅ 物理正确的光照

### 可以扩展的方向

1. **更多材质**
   - 次表面散射（皮肤、蜡）
   - 发光材质（自发光）
   - 各向异性材质（头发、刷痕）

2. **更复杂场景**
   - 三角形网格（.obj 模型）
   - 体积渲染（云、雾）
   - 纹理映射

3. **高级技术**
   - 景深（Depth of Field）
   - 运动模糊（Motion Blur）
   - 重要性采样（加速收敛）
   - 双向路径追踪（更快收敛）

---

## 📚 核心概念总结

1. **路径追踪 = 模拟真实光照的物理过程**

2. **逆向追踪**：从相机发射光线（而不是从光源）

3. **递归反弹**：光线在场景中反复弹跳，收集光照信息

4. **蒙特卡洛**：通过大量随机采样求平均，获得准确结果

5. **材质系统**：决定光线如何散射（反射、折射、吸收）

6. **权衡**：质量 vs 速度

---

## 🎬 动画演示（文字版）

### 一条光线的旅程

```
帧 1: 相机发射光线
     ↓
   [相机]
     
帧 2: 击中蓝色球体
     ↓
   ● ← 蓝色漫反射球
   
帧 3: 散射到随机方向
     ↗
   ●
   
帧 4: 击中黄色地面
     ↓
   ████ ← 黄色地面
   
帧 5: 再次散射
     ↑
   ████
   
帧 6: 击中天空（光源）
   ☀️ ← 收集到天空的蓝白色
   
最终颜色 = 天空色 × 地面色 × 球体色
         = 白蓝 × 黄 × 蓝
         = 略带黄色的浅蓝（这就是你看到的颜色！）
```

---

## 💡 与其他技术的比较

| 技术 | 速度 | 质量 | 应用场景 |
|------|------|------|----------|
| 光栅化 | ⚡⚡⚡ | ⭐⭐ | 实时游戏 |
| 光线追踪 | ⚡⚡ | ⭐⭐⭐ | 混合渲染 |
| 路径追踪 | ⚡ | ⭐⭐⭐⭐⭐ | 电影、建筑 |
| 双向路径追踪 | ⚡ | ⭐⭐⭐⭐⭐ | 复杂光照 |

---

## 🔗 深入学习资源

### 入门
- **Ray Tracing in One Weekend** - 你的项目就基于此
- **Scratchapixel 2.0** - 图形学基础

### 进阶
- **Physically Based Rendering (PBRT)** - 圣经级教材
- **Real-Time Rendering** - 实时渲染技术

### 论文
- Kajiya 1986: "The Rendering Equation" - 渲染方程原始论文
- Veach 1997: "Robust Monte Carlo Methods" - 蒙特卡洛方法

---

希望这个详细的解释帮助你理解了路径追踪的原理！你的项目实现了这些核心概念，是一个完整的、可工作的路径追踪器。